<%  
	def none=[:]
    def hasMany=[:]
    def belongsTo=[:]
    def embed=[]
    def constraints=[]
    def packageName = getPackageName(currentModelElement)
    def parentName = getParentName(currentModelElement)
%>
    
<% if (packageName != '') { %>
package ${packageName}
<% } %>
           
class ${currentModelElement.name} <%if(parentName){%>extends ${parentName}<%}%> {

<%
    getAttributes(currentModelElement).each {attribute ->
        if (!attribute) return
        def attributeName = attribute.name
        def attributeType = friendlyNameType(attribute.type)
        Map attributeTags = taggedValues(attribute)
        StringBuffer c = null
        if(attributeTags.isEmpty()==false) {
            c = new StringBuffer()
            c.append(attributeName + '(')
            attributeTags.each { k, v ->
                c.append(k + ':' + v + ',')
            }
            c.deleteCharAt(c.length()-1)
            c.append(')')
            constraints << c
        }
        def defaultValue = attribute.initialValue?.body
        if(defaultValue != null) { attributeName = attributeName + ' = ' + defaultValue}
        out.println("${attributeType} ${attributeName}")
    }
%>

<%
    getAssociationEnds(model, currentModelElement).each {sourceEnd ->
        def assoc = sourceEnd.association
        def thisEnd = assoc.connection.find {end -> end != sourceEnd}
        if (thisEnd.isNavigable()) {
            def targetName = getEndName(thisEnd)
            if(isManyToOne(thisEnd, sourceEnd)) {
                switch(sourceEnd.aggregation) {
                    case 'ak_none': /*how to deal with none*/ break;
                    case 'ak_aggregate': hasMany[targetName]=getEndTypeName(thisEnd, packageName); break;
                    case 'ak_composite': hasMany[targetName]=getEndTypeName(thisEnd, packageName); break;
                }
            } else if(isOneToMany(thisEnd, sourceEnd)) {
                switch(thisEnd.aggregation) {
                    case 'ak_composite': belongsTo[targetName]=getEndTypeName(thisEnd, packageName); break;
                    case 'ak_aggregate': none[targetName]=getEndTypeName(thisEnd, packageName); break;
                    case 'ak_none': none[targetName]=getEndTypeName(thisEnd, packageName); break;
                }
            } else if(isOneToOne(thisEnd, sourceEnd)) {
                if(sourceEnd.aggregation.toString() == 'ak_composite') {
                   embed << targetName
                }
                none[targetName]=getEndTypeName(thisEnd, packageName);                
            }
              else if(isManyToMany(thisEnd, sourceEnd)) {
                // TODO Many to Many
            }
        }
    }
%>

<%
    none.each{k,v ->
      out.println("${v} ${k}")
    } 
%>

<%
    if(embed.size()>0) {
        def x='static embedded='+embed
        out.println(x.replace('"','\''))
    }
    if(hasMany.size()>0) {
        def x='static hasMany='+hasMany;
        out.println(x.replaceAll('"',''))
    }
    if(belongsTo.size()>0) {
        def x='static belongsTo='+belongsTo;
        out.println(x.replaceAll('"',''))
    }
%>

<% if(constraints.size()>0) { %>
    static constraints = {
<%
    constraints.each{
        out.println(it)
    }
%>
}
<%} // if %>

    String toString() {
        return "\${id}"
    }
   
}

